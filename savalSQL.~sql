------------------------------------------------------------------------------------------------------------------------------------------
                    --------------------------------------Глава 1. Начало------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

-------------------Последовательноси-------------
DROP SEQUENCE m_seq;

CREATE SEQUENCE m_seq
INCREMENT BY 1
START WITH 1
MAXVALUE 9999
NOCYCLE;

--------------------Функции-----------------------
CREATE OR REPLACE FUNCTION get_id RETURN VARCHAR IS
BEGIN
   RETURN SUBSTR(CONCAT('000', m_seq.nextval), -4);
END;
---------------Удаление таблиц-------------------
DROP TABLE staff; 
DROP TABLE shops;
----------------Создание таблиц-------------------
CREATE TABLE shops(
id_shop VARCHAR(4) NOT NULL,
city VARCHAR(20) NOT NULL,
open_time DATE,
close_time DATE,
PRIMARY KEY (id_shop)
);


CREATE TABLE staff(
id_worker VARCHAR(4) NOT NULL,
id_shop VARCHAR(4) NOT NULL,
salary INTEGER,
wname VARCHAR(15) NOT NULL,
age INTEGER,
PRIMARY KEY (id_worker),
CONSTRAINT work_in FOREIGN KEY(id_shop) REFERENCES shops
);
---------------Заполнение таблиц-----------------
INSERT INTO shops VALUES(get_id(), 'Moscow',       to_date('08:00', 'hh24:mi'), to_date('18:00', 'hh24:mi'));
INSERT INTO shops VALUES(get_id(), 'Rostov',       to_date('09:00', 'hh24:mi'), to_date('20:00', 'hh24:mi'));
INSERT INTO shops VALUES(get_id(), 'Samara',       to_date('08:00', 'hh24:mi'), to_date('18:00', 'hh24:mi'));
INSERT INTO shops VALUES(get_id(), 'Omsk',         to_date('09:00', 'hh24:mi'), to_date('20:00', 'hh24:mi'));
INSERT INTO shops VALUES(get_id(), 'Volgograd',    to_date('09:30', 'hh24:mi'), to_date('22:00', 'hh24:mi'));
INSERT INTO shops VALUES(get_id(), 'Krasnodar',    to_date('08:00', 'hh24:mi'), to_date('18:00', 'hh24:mi'));
INSERT INTO shops VALUES(get_id(), 'Strange_city', to_date('05:00', 'hh24:mi'), to_date('23:00', 'hh24:mi'));

INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Rostov'),          12000,       'Олег',    57 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Samara'),          43000,       'Aня',     18 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Krasnodar'),       46000,       'Кирилл',  36 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Samara'),          23000,       'Саша',    45 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Volgograd'),       16000,       'Даша',    34 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Rostov'),          65000,       'Лена',    34 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Moscow'),          32000,       'Вика',    37 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Omsk'),            54000,       'Никита',  28 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Moscow'),          32000,       'Олег',    45 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Rostov'),          12000,       'Саша',    30 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Samara'),          43000,       'Олег',    20 );
INSERT INTO staff VALUES(get_id(), (SELECT id_shop FROM shops WHERE city = 'Volgograd'),       32000,       'Надя',    19 );

-----------------Представления-----------------
CREATE OR REPLACE VIEW view_shops AS
SELECT id_shop, city, to_char(open_time, 'hh24:mi') OPEN_IN, to_char(close_time, 'hh24:mi') CLOSE_IN
FROM shops;
---------------Вывод таблиц----------------------
SELECT * FROM view_shops;
SELECT * FROM staff ORDER BY id_shop;
SELECT * FROM staff NATURAL JOIN view_shops;



--------------------------------------------------SELECT тесты------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------

--DISTINCT
-- Вывести список тех имен, которые имются у сотрудников
SELECT DISTINCT wname AS Имена_сотрудников
FROM staff;

--COUNT(colomn_name), INNER JOIN, UNION, NOT IN, GROUP BY, ORDER BY
-- Вывести общее количество сотрудников в каждом городе.
-- Сортировать по убыванию кол-ва сотрудников
SELECT city, COUNT(id_worker) Количество_сотрудников
FROM shops s INNER JOIN staff w ON s.id_shop = w.id_shop
GROUP BY city
UNION 
SELECT city, 0
FROM shops
WHERE id_shop NOT IN (SELECT DISTINCT id_shop FROM staff)
ORDER BY 2 DESC;

--NATURAL JOIN
-- Вывести всех сотрудников с полной информацией о месте их работы
SELECT *
FROM staff  NATURAL JOIN view_shops 
ORDER BY city;


--HAVING
-- Для всех магазтнов в которых средний возраст сотрудников не превышает 30 лет 
-- Вывести: Город в котором находиться магазин, средний возраст с точность двух знаков после запятой
SELECT city, CAST(AVG(age) AS NUMERIC(5,2)) avg_age
FROM shops s, staff w
WHERE s.id_shop = w.id_shop
GROUP BY city
HAVING AVG(age) <= 30;


--GROUPING SETS
-- Вывести среднюю з/п сотрудника для каждого отдельно взятого магазина
-- и среднюю з/п для всех сотрудников компании
SELECT COALESCE(city, 'Сред. з\п всех') || ' :' AS city, CAST(AVG(salary) AS NUMERIC(10)) AS avg_salary
FROM staff NATURAL JOIN shops
GROUP BY 
GROUPING SETS ((city, id_shop),());

--ROLLUP
-- ???
SELECT wname, open_time, close_time, COUNT(*)
FROM staff NATURAL JOIN shops
GROUP BY ROLLUP(wname, open_time, close_time);
------------------------------------------------------------------------------------------------------------------------------------------
           ---------------------------Глава 2. Таблица bacteriums: CONNECT BY, WITH (рекурсия) ------------------------------
------------------------------------------------------------------------------------------------------------------------------------------
DROP SEQUENCE bact_id;

CREATE SEQUENCE bact_id
INCREMENT BY 1
START WITH -1
MINVALUE -1
MAXVALUE 9999
NOCYCLE;

-----
DROP TABLE Bacteriums;

CREATE TABLE Bacteriums(
b_id INTEGER NOT NULL,
p_id INTEGER,
bname VARCHAR2(30),
weight INTEGER);

INSERT INTO Bacteriums VALUES(bact_id.nextval, NULL, 'Bacterium #'||bact_id.currval||'_adam', 7);


INSERT INTO Bacteriums
SELECT bact_id.nextval,
       dbms_random.value((SELECT MIN(b_id) FROM Bacteriums), bact_id.currval - 1), 
       'Bacterium #'||bact_id.currval,
       dbms_random.value(1,7)
FROM dual
CONNECT BY LEVEL <=10;

INSERT INTO Bacteriums VALUES(bact_id.nextval, NULL, 'Bacterium #'||bact_id.currval||'_null_weight', NULL);
INSERT INTO Bacteriums VALUES(bact_id.nextval, bact_id.currval - 1, 'Bacterium #'||bact_id.currval||'_null_weight_sun', NULL);
UPDATE Bacteriums SET bname = REPLACE(bname, 'sun', 'son'), weight = 1 WHERE b_id = 12;
--------------------------------------------------------
SELECT * FROM Bacteriums;


--TREE with CONNECT BY
--Отобразить:
--дерево происхождения всех бактерий,
--вес отдельно взятой бактерии, вес самой бактерии + вес всех ее потомком,
--вес самой бактерии + вес всех ее предков,
--перечислить через запятую предков клетки
SELECT LPAD('+——', 10*(LEVEL-1), ' ')||bname AS Tree, b_id AS "ID", p_id as  "PARENT",
       weight,
       (SELECT SUM(weight)
       FROM Bacteriums bb
       START WITH bb.b_id = b.b_id
       CONNECT BY PRIOR b_id = p_id) descen_sum,
       (SELECT SUM(weight)
       FROM Bacteriums bb
       START WITH bb.b_id = b.b_id
       CONNECT BY PRIOR p_id = b_id) prior_sum,
       --LEVEL lev,
       --CONNECT_BY_ISLEAF leaf,
       --CONNECT_BY_ROOT bname root,
       CASE
       WHEN (b_id = CONNECT_BY_ROOT b_id)
       THEN NULL
       ELSE SUBSTR(SYS_CONNECT_BY_PATH(PRIOR bname, ', '), 5)
       END life_path
FROM bacteriums b
START WITH p_id IS NULL
CONNECT BY PRIOR b_id = p_id
ORDER SIBLINGS BY bname;

--TREE with WITH RECURSIVE
--Отобразить:
--дерево происхождения всех бактерий,
--вес отдельно взятой бактерии, вес самой бактерии + вес всех ее потомком,
--вес самой бактерии + вес всех ее предков,
--перечислить через запятую предков клетки
WITH Rec (b_id, p_id, bname, lvl, weight, psum, tPath)
     AS (
        SELECT b_id, p_id, bname, 1 , weight, weight AS psum, bname AS tPath
        FROM Bacteriums WHERE p_id IS NULL
        UNION ALL
        SELECT b.b_id, b.p_id, b.bname, r.lvl + 1,
               b.weight, COALESCE(r.psum, 0) + COALESCE(b.weight, 0),
               r.tPath||CAST(', '||b.bname AS VARCHAR2(90)) AS tPath
        FROM Bacteriums b INNER JOIN Rec r ON b.p_id = r.b_id 
        )
        SEARCH DEPTH FIRST BY b_id SET ord
SELECT LPAD('+——', 10*(lvl-1), ' ')||bname AS Tree,-- lvl, ord,
       b_id AS "ID",
       p_id AS "PARENT",
       weight,
       (
       SELECT SUM(weight) --сумма масс клетки и ее потомков
       FROM Bacteriums b
       WHERE b_id IN (
                     SELECT b_id --список id состоящей из id самой клетки и ее потомков
                     FROM Rec rr
                     WHERE rr.ord >= r.ord --где ord на ходится между самой клеткой(включительно) и близжайшим НЕ потомком(не включительно) или конца таблицы при отсутствии НЕ потомка
                     AND rr.ord < COALESCE (
                                           (SELECT min(ord) FROM REC rrr WHERE rrr.ord > r.ord AND rrr.lvl <= r.lvl), --поиск близжайшего НЕ потомка или
                                           (SELECT MAX(ord) FROM Rec) + 1 --конца таблицы
                                           )
                     )
       ) AS descen_sum,
       psum AS prior_sum,
       REPLACE(REPLACE(tPath, ', '||bname), bname) AS life_path
FROM Rec r
ORDER BY ord;
------------------------------------------------------------------------------------------------------------------------------------------
                       -------------------------Глава 3. PIVOT, UNPIVOT и MERGE.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------Таблцица ZOO---
DROP TABLE ZOO;

CREATE TABLE ZOO(
animal VARCHAR2(20) NOT NULL,
zoo_name VARCHAR(30) NOT NULL,
cnt INTEGER NOT NULL);


----------------Заполнение-----
INSERT INTO ZOO VALUES('Обезьяна',       'Центральный Зоопарк', 15);
INSERT INTO ZOO VALUES('Слон',           'Центральный Зоопарк', 3);
INSERT INTO ZOO VALUES('Жираф',          'Центральный Зоопарк', 5);
INSERT INTO ZOO VALUES('Орёл',           'Центральный Зоопарк', 2);
INSERT INTO ZOO VALUES('Носорог',        'Центральный Зоопарк', 3);
INSERT INTO ZOO VALUES('Гиена',          'Центральный Зоопарк', 15);
INSERT INTO ZOO VALUES('Лев',            'Центральный Зоопарк', 3);
INSERT INTO ZOO VALUES('Обезьяна',       'Зоолэнд',             7);
INSERT INTO ZOO VALUES('Слон',           'Зоолэнд',             3);
INSERT INTO ZOO VALUES('Жираф',          'Зоолэнд',             8);
INSERT INTO ZOO VALUES('Орёл',           'Зоолэнд',             12);
INSERT INTO ZOO VALUES('Носорог',        'Зоолэнд',             9);
INSERT INTO ZOO VALUES('Гиена',          'Зоолэнд',             23);
INSERT INTO ZOO VALUES('Лев',            'Зоолэнд',             17);
INSERT INTO ZOO VALUES('Лось',           'Зоолэнд',             12);
INSERT INTO ZOO VALUES('Какаду',         'Зоолэнд',             23);
INSERT INTO ZOO VALUES('Рысь',           'Зоолэнд',             19);
INSERT INTO ZOO VALUES('Обезьяна',       'Тихая поляна',        5);
INSERT INTO ZOO VALUES('Жираф',          'Тихая поляна',        2);
INSERT INTO ZOO VALUES('Носорог',        'Тихая поляна',        1);
INSERT INTO ZOO VALUES('Лось',           'Тихая поляна',        3);

----------------------------
SELECT * FROM ZOO;

--1_1 (PIVOT) 
SELECT ANIMAL, COALESCE(zoo1_cnt, 0) "Центральный Зоопарк", COALESCE(zoo2_cnt, 0) "Зоолэнд", COALESCE(zoo3_cnt, 0) "Тихая поляна"
FROM ZOO
PIVOT(sum(cnt) cnt FOR zoo_name IN('Центральный Зоопарк' zoo1, 'Зоолэнд' zoo2, 'Тихая поляна' zoo3));

--1_2 (PIVOT)
SELECT zoo_name, Monkey_cnt Monkey, Elephant_cnt Elephant,
                 Giraffe_cnt Giraffe, Rhinoceros_cnt Rhinoceros,  Hyena_cnt Hyena,
                 Lion_cnt Lion, Cockatoo_cnt Cockatoo,  Elk_cnt Elk,  Eagle_cnt Eagle,  Lynx_cnt Lynx
FROM ZOO
PIVOT (SUM(cnt) AS cnt FOR animal IN ('Обезьяна' Monkey, 'Слон' Elephant, 'Жираф' Giraffe,
                                     'Носорог' Rhinoceros, 'Гиена' Hyena, 'Лев' Lion,
                                     'Какаду' Cockatoo, 'Лось' Elk, 'Орёл' Eagle, 'Рысь' Lynx));
                                     
----------MERGE----


SELECT * FROM Zoo;--Таблица до изменения

--Поступление животных на временное пользование
MERGE INTO ZOO z
USING (SELECT 'Орёл' animal, 'Центральный Зоопарк' zoo_name,  100 cnt FROM dual
       UNION ALL
       SELECT 'Орёл',        'Зоолэнд',                       200 FROM dual
       UNION ALL
       SELECT 'Рысь',        'Тихая поляна',                  100 FROM dual) an
ON (z.zoo_name = an.zoo_name AND z.animal = an.animal)
WHEN MATCHED THEN
  UPDATE SET z.cnt = z.cnt + an.cnt
WHEN NOT MATCHED THEN
  INSERT(z.animal,  z.zoo_name,  z.cnt)
  VALUES(an.animal, an.zoo_name, an.cnt);
  
SELECT * FROM Zoo;--отобразить временное изменение

MERGE INTO ZOO z
USING (SELECT 'Орёл' animal, 'Центральный Зоопарк' zoo_name,  100 cnt FROM dual
       UNION ALL
       SELECT 'Орёл',        'Зоолэнд',                       200 FROM dual
       UNION ALL
       SELECT 'Рысь',        'Тихая поляна',                  100 FROM dual) an
ON (z.zoo_name = an.zoo_name AND z.animal = an.animal)
WHEN MATCHED THEN
  UPDATE SET z.cnt = z.cnt - an.cnt
  DELETE WHERE z.cnt = 0
WHEN NOT MATCHED THEN
  INSERT(z.animal,  z.zoo_name,  z.cnt)
  VALUES(an.animal, an.zoo_name, an.cnt);
  
SELECT * FROM Zoo;--отобразить конечный результат


--------------------------------Таблица Stock-----
DROP TABLE stocks;

CREATE TABLE Stocks(
city VARCHAR2(20) NOT NULL,
paint INTEGER NOT NULL,
board INTEGER NOT NULL,
toy INTEGER NOT NULL,
PC INTEGER NOT NULL
);


INSERT INTO Stocks VALUES('Ростов', 100, 200, 300, 400);
INSERT INTO Stocks VALUES('Москва', 500, 600, 700, 800);
---------------------------

SELECT * FROM Stocks;

--2 (UNPIVOT)
SELECT * FROM Stocks
UNPIVOT (cnt FOR type_ IN (paint, board, toy, pc));


------------------------------------------------------------------------------------------------------------------------------------------
                             -------------------------Глава 4. Блокировки.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------

DROP SEQUENCE people_seq;

CREATE SEQUENCE people_seq
INCREMENT BY 1
START WITH 1
MAXVALUE 999999
CYCLE;

CREATE OR REPLACE FUNCTION get_people_id RETURN VARCHAR IS
BEGIN
   RETURN SUBSTR(CONCAT('00000', people_seq.nextval), -6);
END;

-----Создание таблицы---
DROP TABLE People;

CREATE TABLE People(
id_p VARCHAR2(6) NOT NULL,
NAME VARCHAR2(50),
age INTEGER,
PRIMARY KEY (id_p));

------заполнение PEOPLE-----
TRUNCATE TABLE People;

              --<<<<<<<<<<<<<<<<<<<<блокировки>>>>>>>>>>>>>>>>>>>--
                                                            | 1 | 2 | 3 | 4 | 5 | sel | ins | upd | del |
LOCK TABLE People IN ROW SHARE MODE NOWAIT;          -- <1> | 1 | 2 | 3 | 4 |   | sel | ins | upd | del |
LOCK TABLE People IN ROW EXCLUSIVE MODE NOWAIT;      -- <2> | 1 | 2 |   |   |   | sel | ins | upd | del |
LOCK TABLE People IN SHARE MODE NOWAIT;              -- <3> | 1 |   | 3 |   |   | sel |     |     |     |
LOCK TABLE People IN SHARE ROW EXCLUSIVE MODE NOWAIT;-- <4> | 1 |   |   |   |   | sel |     |     |     |
LOCK TABLE People IN EXCLUSIVE MODE NOWAIT;          -- <5> |   |   |   |   |   | sel |     |     |     |
              --<<<<<<<<<<<<<<<<<<<<блокировки>>>>>>>>>>>>>>>>>>>--
SELECT * FROM People;

INSERT INTO people
SELECT get_people_id, 'Oleg', dbms_random.value(1, 100)
FROM dual
CONNECT BY LEVEL <= 1;
COMMIT;
--------вывод таблицы----
SELECT * FROM People;
SELECT max(id_p) max_id FROM People;

------------------------------------------------------------------------------------------------------------------------------------------
                           -------------------------Глава 5. Аналитические функции.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------
--приверы с сайта:

Create table PersonA(Tbn number primary key, name varchar2(20), otd number, sal number); 
--Табельный номер , имя, отдел , зарплата

Insert into PersonA(Tbn,name,otd,sal) values(1, 'Аня',10,9000);
Insert into PersonA(Tbn,name,otd,sal) values(2, 'Саша',10,5500);
Insert into PersonA(Tbn,name,otd,sal) values(3, 'Таня',10,7000);
Insert into PersonA(Tbn,name,otd,sal) values(4, 'Ваня',20,2300);
Insert into PersonA(Tbn,name,otd,sal) values(5, 'Олег',20,4300);
Insert into PersonA(Tbn,name,otd,sal) values(6, 'Коля',20,3900);
Insert into PersonA(Tbn,name,otd,sal) values(7, 'Таня',30,7000);
Insert into PersonA(Tbn,name,otd,sal) values(8, 'Макс',30,9000);
Insert into PersonA(Tbn,name,otd,sal) values(9, 'Таня',30,8500);
Insert into PersonA(Tbn,name,otd,sal) values(10,'Макс',30,9900);
Insert into PersonA(Tbn,name,otd,sal) values(11,'Олег',30,9900);
Insert into PersonA(Tbn,name,otd,sal) values(12,'Макс',30,9900);
Insert into PersonA(Tbn,name,otd,sal) values(13,'Макс',30,9900);
Insert into PersonA(Tbn,name,otd,sal) values(14,'Макс',30,9900);
Insert into PersonA(Tbn,name,otd,sal) values(15,'Макс',30,9900);
Insert into PersonA(Tbn,name,otd,sal) values(16,'Макс',30,7000);
Insert into PersonA(Tbn,name,otd,sal) values(17,'Таня',30,3500);


--Запросы списка лидеров
--Первые три сотрудника с самой высокой зарплатой по отделам (партишен по отделу)
select * 
from ( 
     select NAME, otd, sal, row_number() over (partition by otd order by sal desc) AS num 
     from personA
     ) 
where num<4;

--Более корректно 
select * 
from ( 
     select NAME, otd, sal, rank() over (partition by otd order by sal desc) as num 
     from personA
     ) 
where num<4;

--По наименованию (партишен по отделу) сортировка по name
select * 
from ( 
     select NAME, otd, sal, row_number() over (partition by otd order by name) as num 
     from personA
     ) 
where num<4;

--Накопительный итог по зарплате 
select NAME, otd, sal, sum(sal) over (partition by otd order by sal) as num 
from personA;

--Среднее по зарплате в рамках отдела
select NAME, otd, sal,  avg(sal) over (partition by otd order by sal) as num 
from personA;

--Демонстрация работы lag, leed - сотрудник , отдел , зарплата , сотрудник с более большей заплатой (maxsl),
--сотрудник с менее меньшей заплатой чем данный(minsl) в рамках отдела
select NAME, otd, sal, 
       lead(NAME, 1) over (partition by otd order by sal) as maxsl,
       lag(name,1) over (partition by otd order by sal) as minsl
from personA;


--запрос демонстрирует конструкцию окна в рамках отдела , среднее по зарплате,
--вычисляется, не только в рамках отдела , но так же и в рамках окна из 3х строк
SELECT NAME, otd, sal, 
       AVG(sal) OVER(
                     partition by otd 
                     order by sal 
                     ROWS 
                     BETWEEN 1 PRECEDING 
                     AND
                     CURRENT ROW
                     ) as num 
from personA;


--этот запрос демонстрирует применение аналитических функций first_value last_value
select NAME, otd, sal,
       first_value(name) over (partition by otd) as maxsl,
       last_value(name) over (partition by otd) as minsl
from personA;

---------------------мои примеры:
CREATE TABLE pers(
ID INTEGER PRIMARY KEY,
NAME VARCHAR2(20),
salary INTEGER,
dept VARCHAR(10)
);

INSERT INTO pers (id, NAME) VALUES(1,  'Коля');
INSERT INTO pers (id, NAME) VALUES(2,  'Антон');
INSERT INTO pers (id, NAME) VALUES(3,  'Кирилл');
INSERT INTO pers (id, NAME) VALUES(4,  'Таня');
INSERT INTO pers (id, NAME) VALUES(5,  'Антон');
INSERT INTO pers (id, NAME) VALUES(6,  'Коля');
INSERT INTO pers (id, NAME) VALUES(7,  'Кирилл');
INSERT INTO pers (id, NAME) VALUES(8,  'Саша');
INSERT INTO pers (id, NAME) VALUES(9,  'Кирилл');
INSERT INTO pers (id, NAME) VALUES(10, 'Антон');
INSERT INTO pers (id, NAME) VALUES(11, 'Кирилл');
INSERT INTO pers (id, NAME) VALUES(12, 'Аня');
INSERT INTO pers (id, NAME) VALUES(13, 'Антон');
INSERT INTO pers (id, NAME) VALUES(14, 'Антон');
INSERT INTO pers (id, NAME) VALUES(15, 'Саша');
INSERT INTO pers (id, NAME) VALUES(16, 'Аня');
INSERT INTO pers (id, NAME) VALUES(17, 'Коля');
INSERT INTO pers (id, NAME) VALUES(18, 'Кирилл');
INSERT INTO pers (id, NAME) VALUES(19, 'Таня');
INSERT INTO pers (id, NAME) VALUES(20, 'Кирилл');
INSERT INTO pers (id, NAME) VALUES(21, 'Аня');
INSERT INTO pers (id, NAME) VALUES(22, 'Таня');
INSERT INTO pers (id, NAME) VALUES(23, 'Антон');
INSERT INTO pers (id, NAME) VALUES(24, 'Аня');
INSERT INTO pers (id, NAME) VALUES(25, 'Кирилл');
INSERT INTO pers (id, NAME) VALUES(26, 'Аня');
INSERT INTO pers (id, NAME) VALUES(27, 'Коля');
INSERT INTO pers (id, NAME) VALUES(28, 'Саша');
INSERT INTO pers (id, NAME) VALUES(29, 'Аня');
INSERT INTO pers (id, NAME) VALUES(30, 'Антон');
INSERT INTO pers (id, NAME) VALUES(31, 'Кирилл');
INSERT INTO pers (id, NAME) VALUES(32, 'Аня');
INSERT INTO pers (id, NAME) VALUES(33, 'Таня');
INSERT INTO pers (id, NAME) VALUES(34, 'Кирилл');
INSERT INTO pers (id, NAME) VALUES(35, 'Антон');

UPDATE pers s SET 
dept = CASE (
             SELECT dptn 
             FROM  (
                   SELECT p.*, NTILE(3) OVER(ORDER BY ID) AS dptn
                   FROM pers p 
                   ) t 
             WHERE t.id = s.id
             )
       WHEN 1
         THEN 'Ростов'
       WHEN 2
         THEN 'Таганрог'
       WHEN 3
         THEN 'Азов'
       END,
salary = CAST(dbms_random.value(1,9) AS INTEGER)*1000;

SELECT * FROM Pers;

--Посчитать для среднюю зарплату для текущей позиции и двух крайних(по одной слева и справа) в рамках одного отдела
SELECT ID, NAME, dept, salary,
       AVG(salary) OVER(
                        PARTITION BY dept 
                        ORDER BY salary 
                        ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
                       ) AS avg_salary
FROM pers;

--Посчитать корреляцию между зарплатой и размером премии в каждом отделе
SELECT ID, NAME, dept, salary,
       cast(prize AS NUMERIC) AS prize,
       CAST(CORR(salary, prize) OVER(PARTITION BY dept ORDER BY id) AS NUMERIC(5,3)) AS correlation
FROM (
      SELECT p.*, salary * (dbms_random.value(1, 3)/10) AS prize
      FROM pers p
      ) t;
      
--посчитать сумму зарплат для текущего и для предыдущих у которых зп не МЕНЬШЕ 1000 относительно текущей
--посчитать сумму зарплат для текущего и для предыдущих у которых зп не БОЛЬШЕ 1000 относительно текущей
SELECT ID, NAME, dept, salary,
       SUM(salary) OVER(PARTITION BY dept ORDER BY salary ASC RANGE 1000 PRECEDING ) AS summ_before,
       SUM(salary) OVER(PARTITION BY dept ORDER BY salary DESC RANGE 1000 PRECEDING) AS summ_after
FROM Pers p

--для каждой строки отобразить имя чея з/п меньше и больше з/п у текущей строки
--отобразить имя целовека с самой большой/малькой з/п в отделе
SELECT ID, NAME, dept, salary
       LEAD(NAME) OVER(PARTITION BY dept ORDER BY salary) ,
       LAG(NAME) OVER(PARTITION BY dept ORDER BY salary)
FROM Pers;
ORDER BY dept, salary;

------------------------------------------------------------------------------------------------------------------------------------------
                           -------------------------Глава 6. Таблица переводов.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------

DROP TABLE trans2;
CREATE TABLE trans2(
id_from INTEGER NOT NULL,
id_to INTEGER NOT NULL,
dat DATE NOT NULL,
val INTEGER NOT NULL);

LOCK TABLE Savalek.trans2 IN EXCLUSIVE MODE NOWAIT;

--Сначала находим ID таблицы.
select * from all_objects where object_name = 'TRANS';
--Затем находим ID сессии, которая блокирует эту таблицу.
select sid from v$lock where id1 = 188162 or id2 = 188556;
--Затем находим серийный номер сессии
select sid, serial# from v$session where sid = 134
--А потом прибиваем сессию к чертям. Параметр — sid || ',' || serial#
alter system kill session '134,9107' immediate

----Генерирование таблицы
TRUNCATE TABLE trans2;
INSERT INTO trans2
SELECT dbms_random.value(1, 3), --множество id_from 
       dbms_random.value(1, 3), --множество id_to 
       SUBSTR(CONCAT('00', cast(dbms_random.value(1, 19) AS INTEGER)), -2)||'/'||  --день
       SUBSTR(CONCAT('00', cast(dbms_random.value(5, 7) AS INTEGER)), -2)||'/'||   --месяц
       SUBSTR(CONCAT('0000', cast(dbms_random.value(2017, 2017) AS INTEGER)), -4), --год
       cast(dbms_random.value(1, 5) AS INTEGER) * 10 --сумма переводов
FROM dual
CONNECT BY LEVEL<=100;
DELETE FROM trans2
WHERE id_from = id_to;


INSERT INTO trans2 VALUES(1, 4, '19/07/2017', 1000000);

DELETE FROM trans2 WHERE dat = '19/07/2017' AND val = 1000000;
SELECT * FROM trans2;

----Таблица для хранения интервалов
DROP TABLE interval_state_acc;
CREATE TABLE interval_state_acc
(
id_acc INTEGER NOT NULL,
int_beg DATE,
int_end DATE,
state_acc INTEGER NOT NULL,
state_change INTEGER
);

----Просчёт периодов для всех транзакций (Единичный запрос)
TRUNCATE TABLE interval_state_acc;
INSERT INTO INTERVAL_STATE_ACC
  SELECT ID_ACC,
         LAG(DAT, 1) OVER(PARTITION BY ID_ACC ORDER BY DAT) AS INT_BEG,
         DAT AS INT_END,
         COALESCE(SUM(VAL)
                  OVER(PARTITION BY ID_ACC ORDER BY DAT ASC
                       ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING),
                  0) AS STATE_ACC,
         val AS state_change
    FROM (SELECT ID_ACC, DAT, SUM(VAL) VAL
            FROM (SELECT ID_ACC, DAT, SUM(VAL) VAL
                    FROM (SELECT ID_FROM AS ID_ACC, DAT, -VAL AS VAL
                            FROM trans2
                          UNION ALL
                          SELECT ID_TO AS ID_ACC, DAT, VAL AS VAL FROM trans2) TTT
                   GROUP BY ID_ACC, DAT
                  HAVING SUM(VAL) <> 0) TT
           GROUP BY GROUPING SETS((ID_ACC, DAT, VAL),(ID_ACC))) T;
         
SELECT * FROM INTERVAL_STATE_ACC;

----Обновление базы interval_state_acc (Часто выполняемый запрос)
DELETE FROM interval_state_acc
WHERE int_end > SYSDATE - INTERVAL '20' DAY
   OR int_beg > SYSDATE - INTERVAL '20' DAY;

INSERT INTO INTERVAL_STATE_ACC
  SELECT ID_ACC,
         COALESCE(LAG(DAT, 1) OVER(PARTITION BY ID_ACC ORDER BY DAT),
                  (SELECT ISA.INT_END
                     FROM INTERVAL_STATE_ACC ISA
                    WHERE ISA.ID_ACC = T.ID_ACC
                      AND ISA.INT_END =
                          (SELECT MAX(ISA2.INT_END)
                             FROM INTERVAL_STATE_ACC ISA2
                            WHERE ISA2.ID_ACC = ISA.ID_ACC))) AS INT_BEG,
         DAT AS INT_END,
         COALESCE(SUM(VAL)
                  OVER(PARTITION BY ID_ACC ORDER BY DAT ASC
                       ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING),
                  0) + COALESCE((SELECT ISA.STATE_ACC
                                   FROM INTERVAL_STATE_ACC ISA
                                  WHERE ISA.ID_ACC = T.ID_ACC
                                    AND ISA.INT_END =
                                        (SELECT MAX(ISA2.INT_END)
                                           FROM INTERVAL_STATE_ACC ISA2
                                          WHERE ISA2.ID_ACC = ISA.ID_ACC)) +
                                (SELECT ISA.STATE_CHANGE
                                   FROM INTERVAL_STATE_ACC ISA
                                  WHERE ISA.ID_ACC = T.ID_ACC
                                    AND ISA.INT_END =
                                        (SELECT MAX(ISA2.INT_END)
                                           FROM INTERVAL_STATE_ACC ISA2
                                          WHERE ISA2.ID_ACC = ISA.ID_ACC)),
                                0) AS STATE_ACC,
         VAL
    FROM (SELECT ID_ACC, DAT, SUM(VAL) VAL
            FROM (SELECT ID_ACC, DAT, SUM(VAL) AS VAL
                    FROM (SELECT TTTT.*,
                                 ROW_NUMBER() OVER(PARTITION BY ID_ACC ORDER BY DAT) AS ROW_NUM
                            FROM (SELECT ID_FROM AS ID_ACC, DAT, -VAL AS VAL
                                    FROM trans2
                                   WHERE DAT >= SYSDATE - INTERVAL '20' DAY
                                  UNION ALL
                                  SELECT ID_TO AS ID_ACC, DAT, VAL AS VAL
                                    FROM trans2
                                   WHERE DAT >= SYSDATE - INTERVAL '20' DAY) TTTT) TTT
                   GROUP BY ID_ACC, DAT
                  HAVING SUM(VAL) <> 0) TT
           GROUP BY GROUPING SETS((ID_ACC, DAT, VAL),(ID_ACC))) T;

SELECT * FROM INTERVAL_STATE_ACC;

----Представление для отображения периодов
CREATE OR REPLACE VIEW interval_state_acc_view AS
SELECT id_acc as "id",
       COALESCE(CAST(int_beg AS VARCHAR(10)), 'Начало Времён') AS "Начало периода",
       COALESCE(CAST(int_end AS VARCHAR(10)), 'Конец Времён') AS "Конец периода", 
       state_acc AS "Состояние счета"
FROM interval_state_acc
ORDER BY id_acc, int_end;
  
SELECT * FROM interval_state_acc_view;
SELECT * FROM interval_state_acc ORDER BY id_acc, int_beg;

-----------------------------------------Вариант c MERGE-------------------------------------------
----Таблица для хранения интервалов (Merge)
DROP TABLE interval_state_acc_merge2;
CREATE TABLE interval_state_acc_merge2
(
int_num INTEGER NOT NULL,
id_acc INTEGER NOT NULL,
int_beg DATE,
int_end DATE,
state_acc INTEGER NOT NULL,
state_change INTEGER
);

----Просчёт периодов для всех транзакций (Единичный запрос) (Merge)
TRUNCATE TABLE interval_state_acc_merge2;
INSERT INTO interval_state_acc_merge2
  SELECT row_number() OVER(PARTITION BY id_acc ORDER BY DAT) int_num,
         ID_ACC,
         LAG(DAT, 1) OVER(PARTITION BY ID_ACC ORDER BY DAT) AS INT_BEG,
         DAT AS INT_END,
         COALESCE(SUM(VAL)
                  OVER(PARTITION BY ID_ACC ORDER BY DAT ASC
                       ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING),
                  0) AS STATE_ACC,
         val AS state_change
    FROM (SELECT ID_ACC, DAT, SUM(VAL) VAL
            FROM (SELECT ID_ACC, DAT, SUM(VAL) VAL
                    FROM (SELECT ID_FROM AS ID_ACC, DAT, -VAL AS VAL
                            FROM trans2
                          UNION ALL
                          SELECT ID_TO AS ID_ACC, DAT, VAL AS VAL FROM trans2) TTT
                   GROUP BY ID_ACC, DAT
                  HAVING SUM(VAL) <> 0) TT
           GROUP BY GROUPING SETS((ID_ACC, DAT, VAL),(ID_ACC))) T;

SELECT * FROM interval_state_acc_merge2;
--Function (Merge) --(Не участвует в работе)
CREATE OR REPLACE FUNCTION GET_LAST_DATE(ID_ACC IN NUMBER) RETURN DATE IS
BEGIN
  RETURN(
       SELECT MAX(DATE)
       FROM interval_state_acc_merge2 ISA
       WHERE ISA.ID_ACC = ID_ACC
       AND INT_END <= SYSDATE - INTERVAL '20' DAY);
END GET_LAST_DATE;

SELECT GET_LAST_DATE(1) FROM dual;

---view
CREATE OR REPLACE VIEW new_isa AS  
SELECT O.*, MAX(int_num) OVER(PARTITION BY id_acc) AS int_max
FROM (
        SELECT ROW_NUMBER() OVER(PARTITION BY ID_ACC ORDER BY DAT) + COALESCE(((SELECT MAX(INT_NUM) FROM interval_state_acc_merge2 ISA
                                                                        WHERE ISA.ID_ACC = T.ID_ACC AND ISA.INT_END <= SYSDATE - INTERVAL '20' DAY)), 0) INT_NUM,
               ID_ACC,
               COALESCE(LAG(DAT, 1) OVER(PARTITION BY ID_ACC ORDER BY DAT),
                       (SELECT MAX(INT_END) FROM interval_state_acc_merge2 ISA
                        WHERE ISA.ID_ACC = T.ID_ACC  AND ISA.INT_END <= SYSDATE - INTERVAL '20' DAY)
                        ) AS INT_BEG,
               DAT AS INT_END,
               COALESCE(SUM(VAL) OVER(PARTITION BY ID_ACC ORDER BY DAT ASC ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING), 0) + 
                        COALESCE((SELECT ISA.STATE_ACC + ISA.STATE_CHANGE
                                  FROM interval_state_acc_merge2 ISA
                                  WHERE ISA.ID_ACC = T.ID_ACC
                                  AND INT_END = (SELECT MAX(INT_END) FROM interval_state_acc_merge2 ISA
                                                 WHERE ISA.ID_ACC = T.ID_ACC AND ISA.INT_END <= SYSDATE - INTERVAL '20' DAY)),
                        0) AS STATE_ACC,
               VAL AS state_change
          FROM (SELECT ID_ACC, DAT, SUM(VAL) VAL
                  FROM (SELECT ID_ACC, DAT, SUM(VAL) AS VAL
                        FROM (SELECT TTTT.*, ROW_NUMBER() OVER(PARTITION BY ID_ACC ORDER BY DAT) AS ROW_NUM
                              FROM (SELECT ID_FROM AS ID_ACC, DAT, -VAL AS VAL
                                    FROM trans2
                                    WHERE DAT >= SYSDATE - INTERVAL '20' DAY
                                    UNION ALL
                                    SELECT ID_TO AS ID_ACC, DAT, VAL AS VAL
                                    FROM trans2
                                    WHERE DAT >= SYSDATE - INTERVAL '20' DAY
                                    ) TTTT
                             ) TTT
                        GROUP BY ID_ACC, DAT
                        HAVING SUM(VAL) <> 0) TT
                 GROUP BY GROUPING SETS((ID_ACC, DAT, VAL),(ID_ACC))) T
     ) O;


--merge
MERGE INTO interval_state_acc_merge2 isa
USING ( SELECT * FROM new_isa) n_isa 
ON ( isa.id_acc = n_isa.id_acc AND isa.int_num = n_isa.int_num)
  WHEN MATCHED THEN UPDATE
    SET isa.int_beg = n_isa.int_beg,
        isa.int_end = n_isa.int_end,
        isa.state_acc = n_isa.state_acc,
        isa.state_change = n_isa.state_change
        --WHERE isa.int_num = n_isa.int_num
    --DELETE WHERE isa.int_num > n_isa.int_max 
WHEN NOT MATCHED THEN INSERT (isa.int_num, isa.id_acc, isa.int_beg, isa.int_end, isa.state_acc, isa.state_change)
  VALUES(n_isa.int_num, n_isa.id_acc, n_isa.int_beg, n_isa.int_end, n_isa.state_acc, n_isa.state_change);

--вместе с merge (чистка старых записей и удаление не актуальных аккаунтов)
DELETE FROM interval_state_acc_merge2 i
WHERE int_num > (SELECT MAX(int_num) FROM new_isa ii WHERE i.id_acc = ii.id_acc)
OR 0 = (SELECT COUNT(*) FROM new_isa ii WHERE i.id_acc = ii.id_acc);

--temp#################
SELECT * FROM interval_state_acc_merge2;
SELECT * FROM interval_state_acc_merge2_view;

INSERT INTO trans2 VALUES(1, 4, '19/07/2017', 1000000);

DELETE FROM trans2 WHERE val = 1000000;
COMMIT;
SELECT * FROM trans2;
--temp#################
----Представление для отображения периодов (Merge)
CREATE OR REPLACE VIEW interval_state_acc_merge2_view AS
SELECT id_acc as "id",
       COALESCE(CAST(int_beg AS VARCHAR(10)), 'Начало Времён') AS "Начало периода",
       COALESCE(CAST(int_end AS VARCHAR(10)), 'Конец Времён') AS "Конец периода", 
       state_acc AS "Состояние счета"
FROM interval_state_acc_merge2
ORDER BY id_acc, int_end;
  
SELECT * FROM interval_state_acc_merge2_view;
SELECT * FROM interval_state_acc ORDER BY id_acc, int_beg;

------------------------------------------------------------------------------------------------------------------------------------------
                           -------------------------Глава 7. Тарифы и Трафик. 100 дневный период.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------
DROP TABLE Tariff;
CREATE TABLE Tariff
(
id_user NUMBER(10) NOT NULL,
tar_dat DATE NOT NULL,
lim NUMBER(20) CHECK(lim >= 0),
PRIMARY KEY(id_user, tar_dat)
);

DROP TABLE Traffic;
CREATE TABLE Traffic
(
id_user NUMBER(10) NOT NULL,
dat DATE NOT NULL,
amt NUMBER(20)
);

TRUNCATE TABLE Traffic;
TRUNCATE TABLE Tariff;
--user 1 (fair)   +
INSERT INTO traffic VALUES(1, to_date('01/01/2000', 'dd/mm/yyyy'), 100);
INSERT INTO traffic VALUES(1, to_date('01/02/2000', 'dd/mm/yyyy'), 600);
--user 2 (unfair) -
INSERT INTO tariff VALUES (2, to_date('01/01/2000', 'dd/mm/yyyy'), 1000);
INSERT INTO traffic VALUES(2, to_date('01/02/2000 16:00', 'dd/mm/yyyy HH24:MI'), 200);
INSERT INTO traffic VALUES(2, to_date('01/02/2000 16:02', 'dd/mm/yyyy HH24:MI'), 600);
INSERT INTO traffic VALUES(2, to_date('01/03/2000', 'dd/mm/yyyy'), 300);
--user 3 (fair)   +
INSERT INTO tariff VALUES (3, to_date('01/01/2000', 'dd/mm/yyyy'), 1000);
INSERT INTO traffic VALUES(3, to_date('01/02/2000', 'dd/mm/yyyy'), 200);
INSERT INTO traffic VALUES(3, to_date('01/06/2000', 'dd/mm/yyyy'), 200);
--user 4 (unfair) -
INSERT INTO tariff VALUES (4, to_date('01/01/2000', 'dd/mm/yyyy'), 1000);
INSERT INTO traffic VALUES(4, to_date('01/02/2000', 'dd/mm/yyyy'), 900);
INSERT INTO traffic VALUES(4, to_date('01/03/2000', 'dd/mm/yyyy'), 500);
INSERT INTO tariff VALUES (4, to_date('01/04/2000', 'dd/mm/yyyy'), 10000);
--user 5 (fair)   +
INSERT INTO tariff VALUES (5, to_date('01/01/2000', 'dd/mm/yyyy'), 1000);
INSERT INTO traffic VALUES(5, to_date('01/05/2000', 'dd/mm/yyyy'), 500);
INSERT INTO traffic VALUES(5, to_date('01/05/2001', 'dd/mm/yyyy'), 600);
--user 6 (unfair) -
INSERT INTO tariff VALUES (6, to_date('01/01/2000', 'dd/mm/yyyy'), 1000);
INSERT INTO traffic VALUES(6, to_date('01/02/2000', 'dd/mm/yyyy'), 900);
INSERT INTO traffic VALUES(6, to_date('01/04/2000', 'dd/mm/yyyy'), 50);
INSERT INTO tariff VALUES (6, to_date('01/05/2000', 'dd/mm/yyyy'), 900);
--user 7 (fair)   +
INSERT INTO traffic VALUES(7, to_date('01/01/2000', 'dd/mm/yyyy'), 2000);
INSERT INTO tariff VALUES (7, to_date('01/01/2001', 'dd/mm/yyyy'), 1000);
--user 8 (fair)   +
INSERT INTO tariff VALUES(8, to_date('01/01/2000', 'dd/mm/yyyy'), 2000);


-- для view:     
CREATE OR REPLACE VIEW list_ AS
SELECT row_number() OVER(PARTITION BY id_user ORDER BY dat) num_, t.*
FROM (
      SELECT id_user, 'Тариф' type_, lim count_, tar_dat dat
      FROM Tariff
      UNION
      SELECT id_user, 'Трафик' type_, count_, dat
      FROM (
           SELECT id_user, sum(amt) count_, trunc(dat) dat
           FROM Traffic
           GROUP BY id_user, trunc(dat)
           ) tt
      UNION
      SELECT id_user, 'Тариф' type_, (999999) count_, to_date('01/01/1000', 'dd/mm/yyyy') dat -- 99..99 -непреодолимый лимит; 1000 год меньший любого возможного
      FROM (SELECT id_user FROM traffic) tt
     ) t;
------Вывод юзеров:
WITH t_list AS
(SELECT id_user, count_, dat
FROM list_ l WHERE type_ = 'Тариф'
ORDER BY id_user, dat DESC)
SELECT id_user, type_, dat, sum_before_100, limit_before_100, CASE WHEN sum_before_100 <= limit_before_100 THEN '+' ELSE 'CAUGTH' END AS check1,
       sum_after_100, limit_after_100, CASE WHEN sum_after_100 <= limit_after_100 THEN '+' ELSE 'CAUGTH' END AS check2
FROM( SELECT l.*,
           SUM(CASE type_ WHEN 'Трафик' THEN count_ ELSE 0 END) 
           OVER(PARTITION BY id_user ORDER BY dat  RANGE 100 PRECEDING) sum_before_100,
           (SELECT count_ FROM t_list t WHERE t.id_user = l.id_user AND t.dat <= l.dat AND ROWNUM = 1) limit_before_100,
           COALESCE(SUM(CASE type_ WHEN 'Трафик' THEN count_ ELSE 0 END) 
           OVER(PARTITION BY id_user ORDER BY dat RANGE BETWEEN 1 FOLLOWING AND 101 FOLLOWING), 0) sum_after_100,
           (SELECT count_ FROM t_list t WHERE t.id_user = l.id_user AND t.dat <= l.dat + 100 AND ROWNUM = 1) limit_after_100
     FROM list_ l) temp
ORDER BY id_user, num_; 


------------------------------------------------------------------------------------------------------------------------------------------
                     -------------------------Глава 8. Тарифы и Трафик. Период привязанный к тарифу.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------
DROP TABLE Tar;
CREATE TABLE Tar
(
id_user NUMBER(10) NOT NULL,
tar_dat DATE NOT NULL,
lim NUMBER(20) CHECK(lim >= 0),
interval_ NUMBER(7),
PRIMARY KEY(id_user, tar_dat)
);

DROP TABLE Traf;
CREATE TABLE Traf
(
id_user NUMBER(10) NOT NULL,
dat DATE NOT NULL,
amt NUMBER(20)
);

TRUNCATE TABLE Traf;
TRUNCATE TABLE Tar;
--user 1 (fair)   +
INSERT INTO traf VALUES(1, to_date('01/01/2000', 'dd/mm/yyyy'), 1200);
INSERT INTO traf VALUES(1, to_date('01/03/2000', 'dd/mm/yyyy'), 1800);
--user 2 (unfair) -
INSERT INTO traf VALUES(2, to_date('01/05/2000', 'dd/mm/yyyy'), 1000);
INSERT INTO tar VALUES (2, to_date('01/06/2000', 'dd/mm/yyyy'), 2500, 50);
INSERT INTO traf VALUES(2, to_date('01/07/2000', 'dd/mm/yyyy'), 2000);
--user 3 (fair)   +
INSERT INTO traf VALUES(3, to_date('01/02/2000', 'dd/mm/yyyy'), 6000);
INSERT INTO tar VALUES (3, to_date('01/05/2000', 'dd/mm/yyyy'), 10000, 300);
INSERT INTO traf VALUES(3, to_date('01/08/2000', 'dd/mm/yyyy'), 3000);
--user 4 (unfair)   -
INSERT INTO traf VALUES(4, to_date('01/01/1999', 'dd/mm/yyyy'), 3000);
INSERT INTO tar VALUES (4, to_date('01/06/2000', 'dd/mm/yyyy'), 1500, 100);
INSERT INTO traf VALUES(4, to_date('01/01/2002', 'dd/mm/yyyy'), 8000);
--user 5 (unfair) -
INSERT INTO tar VALUES (5, to_date('01/01/2000', 'dd/mm/yyyy'), 1000, 50);
INSERT INTO traf VALUES(5, to_date('01/02/2000', 'dd/mm/yyyy'), 800);
INSERT INTO tar VALUES (5, to_date('01/04/2000', 'dd/mm/yyyy'), 9000, 10);
INSERT INTO traf VALUES(5, to_date('01/09/2000', 'dd/mm/yyyy'), 400);
INSERT INTO tar VALUES (5, to_date('01/11/2000', 'dd/mm/yyyy'), 2000, 500);
INSERT INTO traf VALUES(5, to_date('01/01/2001', 'dd/mm/yyyy'), 900);
--user 6 (unfair) -
INSERT INTO tar VALUES (6, to_date('01/01/2000', 'dd/mm/yyyy'), 500, 100);
INSERT INTO traf VALUES(6, to_date('01/01/2010', 'dd/mm/yyyy'), 1000);
INSERT INTO tar VALUES (6, to_date('01/01/2015', 'dd/mm/yyyy'), 20, 100);
INSERT INTO traf VALUES(6, to_date('01/01/2016', 'dd/mm/yyyy'), 10);

--work
CREATE OR REPLACE VIEW check_view AS 
WITH tar_w AS
(SELECT * FROM tar ORDER BY tar_dat)
SELECT temp.*, CASE wHEN sum_ > lim THEN 'Попался' ELSE '+' END check_
FROM (SELECT t.id_user, t.tar_dat, t.interval_, t.lim, 
             SUM(amt) OVER(PARTITION BY t.id_user, t.tar_dat ORDER BY f.dat) sum_, f.amt,  f.dat
      FROM tar t, (SELECT id_user, TRUNC(dat) dat, sum(amt) amt
                   FROM traf 
                   GROUP BY id_user, TRUNC(dat)) f
      WHERE t.id_user = f.id_user AND ((f.dat >= t.tar_dat - t.interval_) AND 
                                       (f.dat <= t.tar_dat + t.interval_  
                                                OR t.tar_dat = (SELECT MAX(tar_dat) FROM traf tt 
                                                                WHERE tt.id_user = t.id_user)
                                                OR f.dat < (SELECT tt.tar_dat - tt.interval_ FROM tar_w tt 
                                                            WHERE tt.id_user = t.id_user AND t.tar_dat > tt.tar_dat AND ROWNUM = 1) ))
      ) temp
ORDER BY id_user, tar_dat;

--beatiful out
SELECT * FROM check_view
UNION ALL
SELECT null, null, null, null, null, null, null, 
       'Нарушители: '||listagg(id_user, ', ') WITHIN GROUP(ORDER BY id_user)
       FROM (SELECT DISTINCT id_user
             FROM check_view
             WHERE check_ = 'Попался') t;

------------------------------------------------------------------------------------------------------------------------------------------
                           -------------------------Глава (*?:;*"_№2.&&&.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------
CREATE TABLE a
(
i INTEGER
);

CREATE TABLE b
(
i INTEGER
);

TRUNCATE TABLE a;
INSERT INTO a VALUES(1);
INSERT INTO a VALUES(2);
INSERT INTO a VALUES(3);
INSERT INTO a VALUES(4);
INSERT INTO a VALUES(7);
INSERT INTO a VALUES(8);

TRUNCATE TABLE b;
INSERT INTO b VALUES(1);
INSERT INTO b VALUES(1);
INSERT INTO b VALUES(2);
INSERT INTO b VALUES(3);
INSERT INTO b VALUES(8);
INSERT INTO b VALUES(10);

SELECT * FROM a;
SELECT * FROM b;

SELECT *
FROM a FULL JOIN b ON a.i = b.i;
------------------------------------------------------------------------------------------------------------------------------------------
                          -------------------------Глава @?"X_0. RECYCLE BIN.-----------------------
------------------------------------------------------------------------------------------------------------------------------------------
--CONNECT BY
--Генерация n пронумерованных строк
SELECT ROWNUM-11 AS rn FROM dual
CONNECT BY LEVEL <=21;

--Рандом
-------
SELECT CAST(dbms_random.value(1,10) AS NUMERIC(2)) FROM dual;
------


--listagg
SELECT zoo_name, listagg(animal,', ') WITHIN GROUP(ORDER BY animal) animal_list
FROM Zoo
GROUP BY zoo_name;
--
SELECT DBMS_OUTPUT.PUT_LINE(add_ten)
FROM dual;


-------myJavaLibraryTest /begin------
--init 
CREATE OR REPLACE FUNCTION factorial(n IN NUMBER) RETURN NUMBER
AS LANGUAGE JAVA NAME 'SavalClass.fact(long) return long';

--test
SELECT factorial(LEVEL)
FROM dual
CONNECT BY LEVEL <= 30;

-------myJavaLibraryTest /start------
--JAVA----------------------------------------------
----------------------------------------------------------------------
DROP FUNCTION get_ten;

CREATE OR REPLACE FUNCTION add_one(n IN NUMBER) RETURN NUMBER
AS LANGUAGE JAVA NAME 'Adder.addOne (int) return int';

CREATE OR REPLACE FUNCTION mult_ten(n IN NUMBER) RETURN NUMBER
AS LANGUAGE JAVA NAME 'Adder.multTen (int) return int';

--JAVA TEST
SELECT add_one(10) AS a, mult_ten(5) AS b
FROM dual;
-
---------------------JAVA_SAVAL_MATH
--power  long
CREATE OR REPLACE FUNCTION sm_power(x IN NUMBER, st IN NUMBER) RETURN NUMBER
AS LANGUAGE JAVA NAME 'SavMath.power (int, int) return long';

SELECT LEVEL num_, sm_power(2, LEVEL)
FROM dual CONNECT BY LEVEL <= 100;
--power BigInteger 

--list files
CREATE OR REPLACE FUNCTION get_files_list(path_ IN VARCHAR2, max_deep IN NUMBER) RETURN VARCHAR2
AS LANGUAGE JAVA NAME 'SavMath.getFiles (java.lang.String, int) return String';

SELECT get_files_list FROM dual;

DECLARE
BEGIN
  dbms_output.put_line(get_files_list('c:\', 1));
END;

--ARRAY test
CREATE OR REPLACE TYPE fname_array IS VARRAY(3000) OF VARCHAR2(2000);
CREATE OR REPLACE FUNCTION get_array_files(arr IN fname_array) RETURN fname_array
AS LANGUAGE JAVA NAME '';

--httpsGet
CREATE OR REPLACE FUNCTION get_html(url_ IN VARCHAR2) RETURN VARCHAR2
AS LANGUAGE JAVA NAME 'HTTPGet.getHTML (java.lang.String) return String';

	
SET SERVEROUTPUT ON;
SET SERVEROUTPUT ON size '1000000';

BEGIN
  DBMS_OUTPUT.ENABLE(10000000);
  dbms_output.put_line(get_html('http://www.google.ru/'));
END;
--httpGet CLOB
CREATE OR REPLACE FUNCTION get_html_clob (url_ IN VARCHAR2) RETURN CLOB
AS LANGUAGE JAVA NAME 'HTTPGet.getHTML_clob (java.lang.String) return CLOB';

BEGIN
  dbms_output.ENABLE(1000000);
  dbms_output.put_line(get_html_clob('http://www.google.ru/'));
END;


DECLARE
clob_ CLOB;
vchar VARCHAR2(2000 CHAR);
i NUMBER(9);
BEGIN
  dbms_output.ENABLE(100000);
  clob_ := get_html_clob('http://www.google.ru/');
  i := 1;
  --FOR i IN 1..500
    LOOP
      vchar := SUBSTR(clob_, 1 + (i - 1)*100, 100);
      dbms_output.put_line(i||'<>'||(i - 1)*100||'<>'||i*100||'|'||vchar||'|');
      i := i + 1;
      EXIT wHEN i > 200 OR vchar IS NULL;
    END LOOP;
END;


SELECT get_html_clob('http://www.google.ru/') FROM DUAL;

--java example------------------------------------------------
DROP JAVA SOURCE "MyJavaProgInOracle";
DROP FUNCTION say_hello_from_java_to;

CREATE JAVA SOURCE NAMED "MyJavaProgInOracle" AS
public class MyJavaProgInOracle { 
       public static String sayHello (String toWhom) {
              return "Hello my dear friend, " + toWhom + "!";
       }
};

 
CREATE FUNCTION say_hello_from_java_to (to_whom IN VARCHAR2) RETURN VARCHAR2
AS LANGUAGE JAVA
NAME 'MyJavaProgInOracle.sayHello (java.lang.String)
      return java.lang.String';


SELECT say_hello_from_java_to('ALEX') FROM dual;

---RANK and DENSE_RANK and NTILE
SELECT s.*, RANK() OVER(ORDER BY wname) rank_
FROM staff s;

SELECT s.*, DENSE_RANK() OVER(ORDER BY wname DESC) rank_
FROM staff s;

SELECT s.*, NTILE(2) OVER(PARTITION BY wname ORDER BY salary) ntile_
FROM staff s;

--

SELECT * FROM staff
ORDER BY price DESC OFFSET @2*(@1-1) ROWS FETCH NEXT @2 ROWS ONLY;
--
SELECT * FROM staff;
--ROWID
SELECT staff.*, ROWID FROM staff;
--Размер таблицы
  SELECT COALESCE(CAST(ID_WORKER AS VARCHAR2(20)), 'Всего байт:') AS ID_WORKER,
         SUM(VSIZE(ID_WORKER)) BT1,
         COALESCE(CAST(ID_SHOP AS VARCHAR2(20)), 'Всего байт:') AS ID_SHOP,
         SUM(VSIZE(ID_SHOP)) BT2,
         COALESCE(CAST(SALARY AS VARCHAR2(20)), 'Всего байт:') AS SALARY,
         SUM(VSIZE(SALARY)) BT3,
         COALESCE(CAST(WNAME AS VARCHAR2(20)), 'Всего байт:') AS WNAME,
         SUM(VSIZE(WNAME)) BT4,
         COALESCE(CAST(AGE AS VARCHAR2(20)), 'Всего байт:') AS AGE,
         SUM(VSIZE(AGE)) BT5,
         COALESCE(CAST(ROWID AS VARCHAR2(20)), 'Всего байт:') AS ROWID_,
         SUM(VSIZE(ROWID)) BT6
    FROM STAFF
   GROUP BY GROUPING SETS((ID_WORKER, ID_SHOP, SALARY, WNAME, AGE, ROWID),());
--dump
SELECT id_worker, id_shop, salary, wname, age 
FROM staff;

SELECT dump(id_worker), dump(id_shop), dump(salary), dump(wname), dump(age) 
FROM staff;

----Старый вариант транзакций
SELECT id_acc "id",
       COALESCE(CAST(LAG(dat, 1) OVER(PARTITION BY id_acc ORDER BY dat) AS VARCHAR(10)), 'Начало Времён') "Начало периода", 
       COALESCE(CAST(dat AS VARCHAR(10)),'Конец Времён') "Конец периода",
       --lag(true_summ,1) OVER(PARTITION BY id_acc ORDER BY dat) + val true_summ,
       coalesce(SUM(val) OVER(PARTITION BY id_acc ORDER BY dat ASC ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING), 0) AS "Состояние счета"
       --,val 
FROM (SELECT id_acc, dat, sum(val) val
      FROM 
          (
             SELECT id_acc, dat, SUM(val) val
             FROM acc_val_list
             GROUP BY id_acc, dat
             HAVING SUM(val) <> 0
          ) tt
      GROUP BY GROUPING SETS((id_acc, dat, val),(id_acc))
     ) t;
--WHERE dat <> (SELECT MAX(dat) FROM trans WHERE t.id_acc = id_acc) OR dat IS NULL;
---------------------------
------Вывод юзеров:
WITH w_list AS
(SELECT l.*, CASE type_ WHEN 'Тариф' THEN count_ END limit_before_100,
             CASE type_ WHEN 'Тариф' THEN count_ END limit_after_100
FROM list_ l
ORDER BY id_user, dat DESC),
w_list_2 AS 
(SELECT * FROM w_list ORDER BY id_user, dat)
SELECT --num_,
       id_user,
       type_,
       count_,
       dat,
       SUM(CASE type_ WHEN 'Трафик' THEN count_ ELSE 0 END) 
       OVER(PARTITION BY id_user ORDER BY dat  RANGE 100 PRECEDING) sum_before_100,
       coalesce(limit_before_100, (SELECT count_ FROM w_list w WHERE w.type_ = 'Тариф' AND w.id_user = l.id_user 
                                                               AND w.dat < l.dat AND ROWNUM = 1 )) limit_before_100,
       coalesce(SUM(CASE type_ WHEN 'Трафик' THEN count_ ELSE 0 END) 
       OVER(PARTITION BY id_user ORDER BY dat RANGE BETWEEN 1 FOLLOWING AND 101 FOLLOWING), 0) sum_after_100,
       (SELECT count_ FROM w_list_2 w WHERE w.type_ = 'Тариф' AND w.id_user = l.id_user 
                                                               AND w.dat >= (l.dat + 1) AND ROWNUM = 1) limit_after_100
FROM w_list l
ORDER BY id_user, l.num_;
---------------------------
------------

----------













